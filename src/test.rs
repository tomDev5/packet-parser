use anyhow::Context;
use anyhow::Result;
use assert_no_alloc::assert_no_alloc;
use assert_no_alloc::*;
use pnet::packet::icmp::IcmpPacket;
use std::net::IpAddr;

use crate::{
    four_tuple::FourTuple,
    l2::L2Packet,
    l3::L3Packet,
    l4::L4Packet,
    packet::{AfterTunnelStart, Packet},
};

// configuration for no allocation assertion
#[global_allocator]
static A: AllocDisabler = AllocDisabler;

#[test]
fn test_four_tuple() -> Result<()> {
    assert_no_alloc(|| {
        let pkt61 = &[
            0x78u8, 0x2b, 0x46, 0x4b, 0x3b, 0xab, 0xb4, 0x8c, 0x9d, 0x5d, 0x81, 0x8b, 0x08, 0x00,
            0x45, 0x00, 0x00, 0x32, 0x36, 0x2b, 0x40, 0x00, 0x80, 0x06, 0x08, 0x94, 0xc0, 0xa8,
            0x1d, 0x11, 0xc0, 0xa8, 0x1d, 0xa5, 0xec, 0x62, 0x63, 0xdd, 0xc6, 0xef, 0xa3, 0xdf,
            0x88, 0xce, 0x7e, 0xbc, 0x50, 0x18, 0x02, 0x01, 0x0e, 0x83, 0x00, 0x00, 0x08, 0xff,
            0x08, 0x00, 0x07, 0x9e, 0x08, 0x00, 0x00, 0x00,
        ];
        let parsed = Packet::try_from(pkt61.as_slice())?;
        let four_tuple = parsed
            .get_inner_four_tuple()
            .context("Parsing four tuple failed")?;
        let expected = FourTuple {
            source_ip: IpAddr::from([192, 168, 29, 17]),
            source_port: 60514,
            destination_ip: IpAddr::from([192, 168, 29, 165]),
            destination_port: 25565,
        };
        assert_eq!(four_tuple, expected);
        Ok(())
    })
}

#[test]
fn test_gre() -> Result<()> {
    assert_no_alloc(|| {
        let pkt1 = &[
            0xc2, 0x01, 0x57, 0x75, 0x00, 0x00, 0xc2, 0x00, 0x57, 0x75, 0x00, 0x00, 0x08, 0x00,
            0x45, 0x00, 0x00, 0x7c, 0x00, 0x0a, 0x00, 0x00, 0xff, 0x2f, 0xa7, 0x46, 0x0a, 0x00,
            0x00, 0x01, 0x0a, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, 0x00, 0x64,
            0x00, 0x0a, 0x00, 0x00, 0xff, 0x01, 0xb5, 0x89, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
            0x02, 0x02, 0x08, 0x00, 0xbf, 0xd4, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x03, 0xbe, 0x70, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
            0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd, 0xab, 0xcd,
        ];

        let parsed = Packet::try_from(pkt1.as_slice())?;
        let expected_icmp = IcmpPacket::new(&pkt1[58..]).context("Parsing Icmp manually failed")?;

        assert!(matches!(
            parsed,
            Packet::Tunneled(
                L2Packet::Ethernet {
                    header: _,
                    vlans: _,
                    l3: L3Packet::Ipv4(_, L4Packet::Gre(_))
                },
                AfterTunnelStart::L3(L3Packet::Ipv4(_, L4Packet::Icmp(header)))
            ) if header == expected_icmp
        ));

        Ok(())
    })
}
